<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE why3session PUBLIC "-//Why3//proof session v5//EN"
"https://www.why3.org/why3session.dtd">
<why3session shape_version="6">
<prover id="1" name="CVC4" version="1.8" timelimit="2" steplimit="0" memlimit="1000"/>
<prover id="3" name="Alt-Ergo" version="2.5.2" timelimit="2" steplimit="0" memlimit="1000"/>
<file format="whyml" proved="true">
<path name=".."/><path name="Introduction.mlw"/>
</file>
<file format="whyml" proved="true">
<path name=".."/><path name="bsml.mlw"/>
</file>
<file format="whyml" proved="true">
<path name=".."/><path name="average.mlw"/>
<theory name="Average" proved="true">
 <goal name="avg_spec_f" proved="true">
 <proof prover="3"><result status="valid" time="0.119179" steps="324"/></proof>
 </goal>
 <goal name="avg_spec_Nil" proved="true">
 <proof prover="3"><result status="valid" time="0.117833" steps="275"/></proof>
 </goal>
 <goal name="avg_spec_homomophic" proved="true">
 <proof prover="3"><result status="valid" time="0.085139" steps="138"/></proof>
 </goal>
 <goal name="avg_seq&#39;vc" expl="VC for avg_seq" proved="true">
 <proof prover="1"><result status="timeout" time="2.000000" steps="148382"/></proof>
 <proof prover="3"><result status="valid" time="1.657702" steps="13653"/></proof>
 <transf name="split_vc" proved="true" >
  <goal name="avg_seq&#39;vc.0" expl="precondition" proved="true">
  <proof prover="3"><result status="valid" time="0.103893" steps="328"/></proof>
  </goal>
  <goal name="avg_seq&#39;vc.1" expl="postcondition" proved="true">
  <proof prover="1" timelimit="8" memlimit="4000"><result status="timeout" time="8.000000" steps="706744"/></proof>
  <proof prover="3" timelimit="8" memlimit="4000"><result status="timeout" time="8.000000" steps="32192"/></proof>
  <transf name="inline_goal" proved="true" >
   <goal name="avg_seq&#39;vc.1.0" expl="postcondition" proved="true">
   <proof prover="1" timelimit="8" memlimit="4000"><result status="valid" time="5.318511" steps="244759"/></proof>
   </goal>
  </transf>
  </goal>
 </transf>
 </goal>
 <goal name="avg_par&#39;vc" expl="VC for avg_par" proved="true">
 <proof prover="1"><result status="timeout" time="1.667586" steps="98620"/></proof>
 <proof prover="3"><result status="timeout" time="2.000000" steps="10926"/></proof>
 <transf name="split_vc" proved="true" >
  <goal name="avg_par&#39;vc.0" expl="precondition" proved="true">
  <proof prover="3"><result status="valid" time="0.106864" steps="328"/></proof>
  </goal>
  <goal name="avg_par&#39;vc.1" expl="precondition" proved="true">
  <proof prover="3"><result status="valid" time="0.250225" steps="1723"/></proof>
  </goal>
  <goal name="avg_par&#39;vc.2" expl="precondition" proved="true">
  <proof prover="1" timelimit="8" memlimit="4000"><result status="timeout" time="8.000000" steps="629285"/></proof>
  <proof prover="3" timelimit="8" memlimit="4000"><result status="timeout" time="8.000000" steps="36639"/></proof>
  <transf name="inline_goal" proved="true" >
   <goal name="avg_par&#39;vc.2.0" expl="precondition" proved="true">
   <proof prover="1"><result status="timeout" time="2.000000" steps="171054"/></proof>
   <proof prover="3"><result status="timeout" time="2.000000" steps="12600"/></proof>
   <transf name="split_vc" proved="true" >
    <goal name="avg_par&#39;vc.2.0.0" expl="precondition" proved="true">
    <proof prover="3"><result status="valid" time="0.362460" steps="1588"/></proof>
    </goal>
    <goal name="avg_par&#39;vc.2.0.1" expl="precondition" proved="true">
    <proof prover="3"><result status="valid" time="0.364990" steps="1567"/></proof>
    </goal>
   </transf>
   </goal>
  </transf>
  </goal>
  <goal name="avg_par&#39;vc.3" expl="precondition" proved="true">
  <proof prover="3"><result status="valid" time="0.087478" steps="130"/></proof>
  </goal>
  <goal name="avg_par&#39;vc.4" expl="precondition" proved="true">
  <proof prover="3"><result status="valid" time="0.067329" steps="29"/></proof>
  </goal>
  <goal name="avg_par&#39;vc.5" expl="precondition" proved="true">
  <proof prover="3"><result status="valid" time="0.095253" steps="151"/></proof>
  </goal>
  <goal name="avg_par&#39;vc.6" expl="postcondition" proved="true">
  <proof prover="1"><result status="valid" time="0.687350" steps="70815"/></proof>
  </goal>
 </transf>
 </goal>
</theory>
</file>
<file format="whyml" proved="true">
<path name=".."/><path name="count.mlw"/>
<theory name="Count" proved="true">
 <goal name="count_spec_f" proved="true">
 <proof prover="3"><result status="valid" time="0.148835" steps="548"/></proof>
 </goal>
 <goal name="avg_spec_Nil" proved="true">
 <proof prover="3"><result status="valid" time="0.070771" steps="70"/></proof>
 </goal>
 <goal name="count_spec_homomophic" proved="true">
 <proof prover="3"><result status="valid" time="0.121066" steps="299"/></proof>
 </goal>
 <goal name="count_seq&#39;vc" expl="VC for count_seq" proved="true">
 <proof prover="1"><result status="timeout" time="2.000000" steps="128597"/></proof>
 <proof prover="3"><result status="valid" time="1.983384" steps="12353"/></proof>
 <transf name="split_vc" proved="true" >
  <goal name="count_seq&#39;vc.0" expl="precondition" proved="true">
  <proof prover="3"><result status="valid" time="0.108540" steps="265"/></proof>
  </goal>
  <goal name="count_seq&#39;vc.1" expl="postcondition" proved="true">
  <proof prover="1" timelimit="8" memlimit="4000"><result status="valid" time="2.855302" steps="243008"/></proof>
  </goal>
 </transf>
 </goal>
 <goal name="count_par&#39;vc" expl="VC for count_par" proved="true">
 <proof prover="1"><result status="timeout" time="2.000000" steps="138381"/></proof>
 <proof prover="3"><result status="timeout" time="2.000000" steps="14908"/></proof>
 <transf name="split_vc" proved="true" >
  <goal name="count_par&#39;vc.0" expl="precondition" proved="true">
  <proof prover="3"><result status="valid" time="0.116823" steps="265"/></proof>
  </goal>
  <goal name="count_par&#39;vc.1" expl="precondition" proved="true">
  <proof prover="3"><result status="valid" time="0.095924" steps="143"/></proof>
  </goal>
  <goal name="count_par&#39;vc.2" expl="precondition" proved="true">
  <proof prover="3"><result status="valid" time="0.253014" steps="1002"/></proof>
  </goal>
  <goal name="count_par&#39;vc.3" expl="precondition" proved="true">
  <proof prover="3"><result status="valid" time="0.096054" steps="133"/></proof>
  </goal>
  <goal name="count_par&#39;vc.4" expl="precondition" proved="true">
  <proof prover="3"><result status="valid" time="0.065251" steps="32"/></proof>
  </goal>
  <goal name="count_par&#39;vc.5" expl="precondition" proved="true">
  <proof prover="3"><result status="valid" time="0.095314" steps="152"/></proof>
  </goal>
  <goal name="count_par&#39;vc.6" expl="postcondition" proved="true">
  <proof prover="3" timelimit="8" memlimit="4000"><result status="valid" time="1.498979" steps="10590"/></proof>
  </goal>
 </transf>
 </goal>
</theory>
</file>
<file format="whyml">
<path name=".."/><path name="mps.mlw"/>
<theory name="MPS">
 <goal name="mps_spec&#39;vc" expl="VC for mps_spec" proved="true">
 <proof prover="3"><result status="valid" time="0.052714" steps="35"/></proof>
 </goal>
 <goal name="op&#39;vc" expl="VC for op" proved="true">
 <proof prover="3"><result status="valid" time="0.046683" steps="12"/></proof>
 </goal>
 <goal name="f&#39;vc" expl="VC for f" proved="true">
 <proof prover="3"><result status="valid" time="0.048112" steps="12"/></proof>
 </goal>
 <goal name="op_assoc" proved="true">
 <proof prover="3"><result status="valid" time="0.299844" steps="1927"/></proof>
 </goal>
 <goal name="op_neutral" proved="true">
 <proof prover="1" timelimit="8" memlimit="4000"><result status="timeout" time="8.000000" steps="850896"/></proof>
 <proof prover="3" timelimit="8" memlimit="4000"><result status="timeout" time="8.000000" steps="42728"/></proof>
 <transf name="inline_goal" proved="true" >
  <goal name="op_neutral.0" proved="true">
  <proof prover="1"><result status="timeout" time="2.000000" steps="188442"/></proof>
  <proof prover="3"><result status="valid" time="1.996384" steps="16732"/></proof>
  <transf name="split_vc" proved="true" >
   <goal name="op_neutral.0.0" proved="true">
   <proof prover="3"><result status="valid" time="0.217786" steps="1538"/></proof>
   </goal>
   <goal name="op_neutral.0.1" proved="true">
   <proof prover="3"><result status="valid" time="0.346300" steps="1489"/></proof>
   </goal>
  </transf>
  </goal>
 </transf>
 </goal>
 <goal name="op_preserves_mps_sum_inv" proved="true">
 <proof prover="3"><result status="valid" time="0.356867" steps="2319"/></proof>
 </goal>
 <goal name="mps_sum_inv_neutral" proved="true">
 <proof prover="3"><result status="valid" time="0.074074" steps="108"/></proof>
 </goal>
 <goal name="f_establishes_mps_sum_inv" proved="true">
 <proof prover="3"><result status="valid" time="0.088290" steps="173"/></proof>
 </goal>
 <goal name="maximum_map_plus&#39;vc" expl="VC for maximum_map_plus" proved="true">
 <proof prover="1"><result status="timeout" time="2.000000" steps="169313"/></proof>
 <proof prover="3"><result status="timeout" time="2.000000" steps="17858"/></proof>
 <transf name="split_vc" proved="true" >
  <goal name="maximum_map_plus&#39;vc.0" expl="unreachable point" proved="true">
  <proof prover="3"><result status="valid" time="0.051215" steps="22"/></proof>
  </goal>
  <goal name="maximum_map_plus&#39;vc.1" expl="variant decrease" proved="true">
  <proof prover="3"><result status="valid" time="0.119700" steps="232"/></proof>
  </goal>
  <goal name="maximum_map_plus&#39;vc.2" expl="precondition" proved="true">
  <proof prover="3"><result status="valid" time="0.084027" steps="122"/></proof>
  </goal>
  <goal name="maximum_map_plus&#39;vc.3" expl="postcondition" proved="true">
  <proof prover="1"><result status="timeout" time="2.000000" steps="251933"/></proof>
  <proof prover="3"><result status="timeout" time="2.000000" steps="13216"/></proof>
  <transf name="split_vc" proved="true" >
   <goal name="maximum_map_plus&#39;vc.3.0" expl="postcondition" proved="true">
   <proof prover="3"><result status="valid" time="0.209585" steps="717"/></proof>
   </goal>
   <goal name="maximum_map_plus&#39;vc.3.1" expl="postcondition" proved="true">
   <proof prover="3"><result status="valid" time="0.310485" steps="1132"/></proof>
   </goal>
  </transf>
  </goal>
 </transf>
 </goal>
 <goal name="mps_spec_cons&#39;vc" expl="VC for mps_spec_cons">
 <proof prover="1"><result status="timeout" time="2.000000" steps="159997"/></proof>
 <proof prover="3"><result status="timeout" time="2.000000" steps="9575"/></proof>
 <transf name="split_vc" >
  <goal name="mps_spec_cons&#39;vc.0" expl="assertion" proved="true">
  <proof prover="3"><result status="valid" time="0.107456" steps="261"/></proof>
  </goal>
  <goal name="mps_spec_cons&#39;vc.1" expl="precondition" proved="true">
  <proof prover="3"><result status="valid" time="0.074505" steps="54"/></proof>
  </goal>
  <goal name="mps_spec_cons&#39;vc.2" expl="precondition" proved="true">
  <proof prover="3"><result status="valid" time="0.159621" steps="465"/></proof>
  </goal>
  <goal name="mps_spec_cons&#39;vc.3" expl="postcondition">
  <proof prover="1" timelimit="8" memlimit="4000"><result status="timeout" time="8.000000" steps="562361"/></proof>
  <proof prover="3" timelimit="8" memlimit="4000"><result status="timeout" time="8.000000" steps="37473"/></proof>
  <transf name="inline_goal" >
   <goal name="mps_spec_cons&#39;vc.3.0" expl="postcondition">
   <proof prover="1" timelimit="32" memlimit="4000"><undone/></proof>
   </goal>
  </transf>
  </goal>
 </transf>
 </goal>
 <goal name="mps_spec_pos&#39;vc" expl="VC for mps_spec_pos">
 <proof prover="1"><result status="timeout" time="2.000000" steps="123142"/></proof>
 <proof prover="3"><result status="timeout" time="2.000000" steps="8696"/></proof>
 <transf name="split_vc" >
  <goal name="mps_spec_pos&#39;vc.0" expl="postcondition">
  <proof prover="1"><undone/></proof>
  </goal>
  <goal name="mps_spec_pos&#39;vc.1" expl="postcondition">
  <proof prover="3"><undone/></proof>
  </goal>
 </transf>
 </goal>
 <goal name="ms_cons&#39;vc" expl="VC for ms_cons">
 <proof prover="3"><undone/></proof>
 </goal>
 <goal name="ms_f">
 <proof prover="1"><undone/></proof>
 </goal>
 <goal name="ms_homomorphic&#39;vc" expl="VC for ms_homomorphic">
 <proof prover="1"><undone/></proof>
 <proof prover="3"><undone/></proof>
 <transf name="split_vc" >
  <goal name="ms_homomorphic&#39;vc.0" expl="assertion">
  <proof prover="3"><undone/></proof>
  </goal>
  <goal name="ms_homomorphic&#39;vc.1" expl="assertion">
  <proof prover="3"><undone/></proof>
  </goal>
  <goal name="ms_homomorphic&#39;vc.2" expl="assertion">
  <proof prover="3"><undone/></proof>
  </goal>
  <goal name="ms_homomorphic&#39;vc.3" expl="assertion">
  <proof prover="3"><undone/></proof>
  </goal>
  <goal name="ms_homomorphic&#39;vc.4" expl="assertion">
  <proof prover="3"><undone/></proof>
  </goal>
  <goal name="ms_homomorphic&#39;vc.5" expl="assertion">
  <proof prover="3"><undone/></proof>
  </goal>
  <goal name="ms_homomorphic&#39;vc.6" expl="postcondition">
  <proof prover="1"><undone/></proof>
  </goal>
 </transf>
 </goal>
 <goal name="mps_seq&#39;vc" expl="VC for mps_seq">
 <proof prover="1"><undone/></proof>
 <proof prover="3"><undone/></proof>
 <transf name="split_vc" >
  <goal name="mps_seq&#39;vc.0" expl="precondition">
  <proof prover="3"><undone/></proof>
  </goal>
  <goal name="mps_seq&#39;vc.1" expl="assertion">
  <proof prover="1" timelimit="8" memlimit="4000"><undone/></proof>
  </goal>
  <goal name="mps_seq&#39;vc.2" expl="postcondition">
  <proof prover="3"><undone/></proof>
  </goal>
 </transf>
 </goal>
 <goal name="mps_par&#39;vc" expl="VC for mps_par">
 <proof prover="1"><undone/></proof>
 <proof prover="3"><undone/></proof>
 <transf name="split_vc" >
  <goal name="mps_par&#39;vc.0" expl="precondition">
  <proof prover="3"><undone/></proof>
  </goal>
  <goal name="mps_par&#39;vc.1" expl="precondition">
  <proof prover="3"><undone/></proof>
  </goal>
  <goal name="mps_par&#39;vc.2" expl="precondition">
  <proof prover="3"><undone/></proof>
  </goal>
  <goal name="mps_par&#39;vc.3" expl="precondition">
  <proof prover="3"><undone/></proof>
  </goal>
  <goal name="mps_par&#39;vc.4" expl="precondition">
  <proof prover="3"><undone/></proof>
  </goal>
  <goal name="mps_par&#39;vc.5" expl="postcondition">
  <proof prover="3"><undone/></proof>
  </goal>
 </transf>
 </goal>
</theory>
</file>
<file format="whyml">
<path name=".."/><path name="sequential.mlw"/>
<theory name="Int">
 <goal name="max&#39;vc" expl="VC for max">
 <proof prover="3"><undone/></proof>
 </goal>
 <goal name="min&#39;vc" expl="VC for min">
 <proof prover="3"><undone/></proof>
 </goal>
</theory>
<theory name="Algebra">
 <goal name="tail_satisfies_aux">
 <proof prover="3"><undone/></proof>
 </goal>
 <goal name="tail_satisfies">
 <proof prover="1"><undone/></proof>
 </goal>
 <goal name="tail_satisfies_head">
 <proof prover="3"><undone/></proof>
 </goal>
 <goal name="max_assoc">
 <proof prover="3"><undone/></proof>
 </goal>
 <goal name="add_assoc">
 <proof prover="3"><undone/></proof>
 </goal>
 <goal name="add_neutral">
 <proof prover="3"><undone/></proof>
 </goal>
 <goal name="max_add_distr">
 <proof prover="3"><undone/></proof>
 </goal>
</theory>
<theory name="ListExtensionality">
 <goal name="extensionality&#39;vc" expl="VC for extensionality">
 <proof prover="3"><undone/></proof>
 </goal>
</theory>
<theory name="ListAppend">
 <goal name="app_cons">
 <proof prover="3"><undone/></proof>
 </goal>
 <goal name="app_satisfies&#39;vc" expl="VC for app_satisfies">
 <proof prover="3"><undone/></proof>
 </goal>
 <goal name="app_assoc">
 <proof prover="3"><undone/></proof>
 </goal>
 <goal name="app_neutral">
 <proof prover="3"><undone/></proof>
 </goal>
 <goal name="nth_append_left&#39;vc" expl="VC for nth_append_left">
 <proof prover="3"><undone/></proof>
 </goal>
 <goal name="nth_append_right&#39;vc" expl="VC for nth_append_right">
 <proof prover="3"><undone/></proof>
 </goal>
</theory>
<theory name="ListInit">
 <goal name="init_aux&#39;vc" expl="VC for init_aux">
 <proof prover="3"><undone/></proof>
 </goal>
 <goal name="init&#39;vc" expl="VC for init">
 <proof prover="3"><undone/></proof>
 </goal>
 <goal name="from_to&#39;vc" expl="VC for from_to">
 <proof prover="3"><undone/></proof>
 </goal>
 <goal name="from_to_succ&#39;vc" expl="VC for from_to_succ">
 <proof prover="1"><undone/></proof>
 </goal>
</theory>
<theory name="ListRev">
 <goal name="rev_aux&#39;vc" expl="VC for rev_aux">
 <proof prover="3"><undone/></proof>
 </goal>
 <goal name="rev&#39;vc" expl="VC for rev">
 <proof prover="3"><undone/></proof>
 </goal>
</theory>
<theory name="ListMap">
 <goal name="map&#39;vc" expl="VC for map">
 <proof prover="3"><undone/></proof>
 </goal>
 <goal name="map_ext&#39;vc" expl="VC for map_ext">
 <proof prover="3"><undone/></proof>
 </goal>
 <goal name="map_map&#39;vc" expl="VC for map_map">
 <proof prover="3"><undone/></proof>
 </goal>
 <goal name="map_app&#39;vc" expl="VC for map_app">
 <proof prover="3"><undone/></proof>
 </goal>
 <goal name="map_cons">
 <proof prover="3"><undone/></proof>
 </goal>
</theory>
<theory name="ListMapAlg">
 <goal name="map_ext_inv&#39;vc" expl="VC for map_ext_inv">
 <proof prover="3"><undone/></proof>
 </goal>
</theory>
<theory name="ListTailRecMap">
 <goal name="map_aux&#39;vc" expl="VC for map_aux">
 <proof prover="3"><undone/></proof>
 </goal>
 <goal name="map&#39;&#39;vc" expl="VC for map&#39;">
 <proof prover="3"><undone/></proof>
 </goal>
 <goal name="map&#39;_map">
 <proof prover="3"><undone/></proof>
 </goal>
</theory>
<theory name="ListMap2">
 <goal name="map2&#39;vc" expl="VC for map2">
 <proof prover="3"><undone/></proof>
 </goal>
</theory>
<theory name="ListMap3">
 <goal name="map3&#39;vc" expl="VC for map3">
 <proof prover="3"><undone/></proof>
 </goal>
</theory>
<theory name="ListFold">
 <goal name="fold_left&#39;vc" expl="VC for fold_left">
 <proof prover="3"><undone/></proof>
 </goal>
 <goal name="fold_left_app&#39;vc" expl="VC for fold_left_app">
 <proof prover="3"><undone/></proof>
 </goal>
 <goal name="fold_left_map_r&#39;vc" expl="VC for fold_left_map_r">
 <proof prover="1"><undone/></proof>
 <proof prover="3"><undone/></proof>
 <transf name="split_vc" >
  <goal name="fold_left_map_r&#39;vc.0" expl="postcondition">
  <proof prover="3"><undone/></proof>
  </goal>
  <goal name="fold_left_map_r&#39;vc.1" expl="postcondition">
  <proof prover="1"><undone/></proof>
  </goal>
 </transf>
 </goal>
</theory>
<theory name="ListFoldMonoid">
 <goal name="fold_left_inv&#39;vc" expl="VC for fold_left_inv">
 <proof prover="3"><undone/></proof>
 </goal>
 <goal name="fold_left_preserves&#39;vc" expl="VC for fold_left_preserves">
 <proof prover="3"><undone/></proof>
 </goal>
 <goal name="fold_left_prop&#39;vc" expl="VC for fold_left_prop">
 <proof prover="3"><undone/></proof>
 </goal>
 <goal name="fold_left_app_prop&#39;vc" expl="VC for fold_left_app_prop">
 <proof prover="3"><undone/></proof>
 </goal>
</theory>
<theory name="ListFlatten">
 <goal name="flatten_cons&#39;vc" expl="VC for flatten_cons">
 <proof prover="3"><undone/></proof>
 </goal>
 <goal name="flatten_map&#39;vc" expl="VC for flatten_map">
 <proof prover="3"><undone/></proof>
 </goal>
 <goal name="flatten_app&#39;vc" expl="VC for flatten_app">
 <proof prover="3"><undone/></proof>
 </goal>
 <goal name="flatten_fequal">
 <proof prover="3"><undone/></proof>
 </goal>
</theory>
<theory name="ListFlattenAlg">
 <goal name="flatten_satisfies&#39;vc" expl="VC for flatten_satisfies">
 <proof prover="3"><undone/></proof>
 </goal>
 <goal name="fold_left_flatten&#39;vc" expl="VC for fold_left_flatten">
 <proof prover="1"><undone/></proof>
 <proof prover="3"><undone/></proof>
 <transf name="split_vc" >
  <goal name="fold_left_flatten&#39;vc.0" expl="precondition">
  <proof prover="3"><undone/></proof>
  </goal>
  <goal name="fold_left_flatten&#39;vc.1" expl="precondition">
  <proof prover="3"><undone/></proof>
  </goal>
  <goal name="fold_left_flatten&#39;vc.2" expl="precondition">
  <proof prover="3"><undone/></proof>
  </goal>
  <goal name="fold_left_flatten&#39;vc.3" expl="precondition">
  <proof prover="3"><undone/></proof>
  </goal>
  <goal name="fold_left_flatten&#39;vc.4" expl="precondition">
  <proof prover="3"><undone/></proof>
  </goal>
  <goal name="fold_left_flatten&#39;vc.5" expl="precondition">
  <proof prover="3"><undone/></proof>
  </goal>
  <goal name="fold_left_flatten&#39;vc.6" expl="precondition">
  <proof prover="3"><undone/></proof>
  </goal>
  <goal name="fold_left_flatten&#39;vc.7" expl="precondition">
  <proof prover="3"><undone/></proof>
  </goal>
  <goal name="fold_left_flatten&#39;vc.8" expl="precondition">
  <proof prover="3"><undone/></proof>
  </goal>
  <goal name="fold_left_flatten&#39;vc.9" expl="precondition">
  <proof prover="3"><undone/></proof>
  </goal>
  <goal name="fold_left_flatten&#39;vc.10" expl="precondition">
  <proof prover="3"><undone/></proof>
  </goal>
  <goal name="fold_left_flatten&#39;vc.11" expl="precondition">
  <proof prover="3"><undone/></proof>
  </goal>
  <goal name="fold_left_flatten&#39;vc.12" expl="postcondition">
  <proof prover="1"><undone/></proof>
  <proof prover="3"><undone/></proof>
  <transf name="split_vc" >
   <goal name="fold_left_flatten&#39;vc.12.0" expl="postcondition">
   <proof prover="3"><undone/></proof>
   </goal>
   <goal name="fold_left_flatten&#39;vc.12.1" expl="postcondition">
   <proof prover="3"><undone/></proof>
   </goal>
  </transf>
  </goal>
 </transf>
 </goal>
</theory>
<theory name="ListSum">
 <goal name="sum_cons&#39;vc" expl="VC for sum_cons">
 <proof prover="3"><undone/></proof>
 </goal>
 <goal name="sum_app&#39;vc" expl="VC for sum_app">
 <proof prover="3"><undone/></proof>
 </goal>
</theory>
<theory name="ListMaximum">
 <goal name="maximum&#39;vc" expl="VC for maximum">
 <proof prover="3"><undone/></proof>
 </goal>
 <goal name="maximum_cons">
 <proof prover="1"><undone/></proof>
 </goal>
</theory>
<theory name="ListFirstHomomorphismTheorem">
 <goal name="fold_left_homomorphic&#39;vc" expl="VC for fold_left_homomorphic">
 <proof prover="1"><undone/></proof>
 </goal>
 <goal name="first_homomorphism_theorem&#39;vc" expl="VC for first_homomorphism_theorem">
 <proof prover="1"><undone/></proof>
 <proof prover="3"><undone/></proof>
 <transf name="split_vc" >
  <goal name="first_homomorphism_theorem&#39;vc.0" expl="precondition">
  <proof prover="3"><undone/></proof>
  </goal>
  <goal name="first_homomorphism_theorem&#39;vc.1" expl="precondition">
  <proof prover="3"><undone/></proof>
  </goal>
  <goal name="first_homomorphism_theorem&#39;vc.2" expl="postcondition">
  <proof prover="1"><undone/></proof>
  <proof prover="3"><undone/></proof>
  <transf name="split_vc" >
   <goal name="first_homomorphism_theorem&#39;vc.2.0" expl="postcondition">
   <proof prover="3"><undone/></proof>
   </goal>
   <goal name="first_homomorphism_theorem&#39;vc.2.1" expl="postcondition">
   <proof prover="1"><undone/></proof>
   </goal>
  </transf>
  </goal>
 </transf>
 </goal>
</theory>
<theory name="ListFirstnSkipn">
 <goal name="cut&#39;vc" expl="VC for cut">
 <proof prover="3"><undone/></proof>
 </goal>
 <goal name="firstn&#39;vc" expl="VC for firstn">
 <proof prover="3"><undone/></proof>
 </goal>
 <goal name="skipn&#39;vc" expl="VC for skipn">
 <proof prover="3"><undone/></proof>
 </goal>
 <goal name="firstn_skipn&#39;vc" expl="VC for firstn_skipn">
 <proof prover="3"><undone/></proof>
 </goal>
 <goal name="skipn_skipn&#39;vc" expl="VC for skipn_skipn">
 <proof prover="3"><undone/></proof>
 </goal>
 <goal name="take&#39;vc" expl="VC for take">
 <proof prover="3"><undone/></proof>
 </goal>
</theory>
<theory name="ListPrefix">
 <goal name="prefix&#39;vc" expl="VC for prefix">
 <proof prover="1"><undone/></proof>
 <proof prover="3"><undone/></proof>
 <transf name="split_vc" >
  <goal name="prefix&#39;vc.0" expl="variant decrease">
  <proof prover="3"><undone/></proof>
  </goal>
  <goal name="prefix&#39;vc.1" expl="postcondition">
  <proof prover="1"><undone/></proof>
  <proof prover="3"><undone/></proof>
  <transf name="split_vc" >
   <goal name="prefix&#39;vc.1.0" expl="postcondition">
   <proof prover="3"><undone/></proof>
   </goal>
   <goal name="prefix&#39;vc.1.1" expl="postcondition">
   <proof prover="3"><undone/></proof>
   </goal>
  </transf>
  </goal>
  <goal name="prefix&#39;vc.2" expl="postcondition">
  <proof prover="1"><undone/></proof>
  <proof prover="3"><undone/></proof>
  <transf name="split_vc" >
   <goal name="prefix&#39;vc.2.0" expl="postcondition">
   <proof prover="3"><undone/></proof>
   </goal>
   <goal name="prefix&#39;vc.2.1" expl="postcondition">
   <proof prover="3"><undone/></proof>
   </goal>
  </transf>
  </goal>
 </transf>
 </goal>
 <goal name="prefix_cons">
 <proof prover="3"><undone/></proof>
 </goal>
 <goal name="prefix_map&#39;vc" expl="VC for prefix_map">
 <proof prover="3"><undone/></proof>
 </goal>
 <goal name="prefix_satisfies&#39;vc" expl="VC for prefix_satisfies">
 <proof prover="3"><undone/></proof>
 </goal>
</theory>
<theory name="ListFilter">
 <goal name="filter_append&#39;vc" expl="VC for filter_append">
 <proof prover="3"><undone/></proof>
 </goal>
</theory>
<theory name="ListZip">
 <goal name="zip_length&#39;vc" expl="VC for zip_length">
 <proof prover="3"><undone/></proof>
 </goal>
 <goal name="zip_map2&#39;vc" expl="VC for zip_map2">
 <proof prover="1"><undone/></proof>
 </goal>
 <goal name="zip_nth">
 <proof prover="3"><undone/></proof>
 </goal>
</theory>
<theory name="ListScan">
 <goal name="scanl_spec&#39;vc" expl="VC for scanl_spec">
 <proof prover="1"><undone/></proof>
 <proof prover="3"><undone/></proof>
 <transf name="split_vc" >
  <goal name="scanl_spec&#39;vc.0" expl="assertion">
  <proof prover="1"><undone/></proof>
  </goal>
  <goal name="scanl_spec&#39;vc.1" expl="assertion">
  <proof prover="3"><undone/></proof>
  </goal>
  <goal name="scanl_spec&#39;vc.2" expl="assertion">
  <proof prover="1"><undone/></proof>
  </goal>
  <goal name="scanl_spec&#39;vc.3" expl="assertion">
  <proof prover="1"><undone/></proof>
  </goal>
  <goal name="scanl_spec&#39;vc.4" expl="postcondition">
  <proof prover="1"><undone/></proof>
  <proof prover="3"><undone/></proof>
  <transf name="split_vc" >
   <goal name="scanl_spec&#39;vc.4.0" expl="postcondition">
   <proof prover="1" timelimit="32" memlimit="4000"><undone/></proof>
   </goal>
   <goal name="scanl_spec&#39;vc.4.1" expl="postcondition">
   <proof prover="3"><undone/></proof>
   </goal>
  </transf>
  </goal>
 </transf>
 </goal>
 <goal name="scanl_nth&#39;vc" expl="VC for scanl_nth">
 <proof prover="3"><undone/></proof>
 </goal>
 <goal name="scanl_snoc&#39;vc" expl="VC for scanl_snoc">
 <proof prover="1"><undone/></proof>
 <proof prover="3"><undone/></proof>
 <transf name="split_vc" >
  <goal name="scanl_snoc&#39;vc.0" expl="postcondition">
  <proof prover="1"><undone/></proof>
  </goal>
  <goal name="scanl_snoc&#39;vc.1" expl="postcondition">
  <proof prover="1"><undone/></proof>
  </goal>
 </transf>
 </goal>
 <goal name="scanl_length&#39;vc" expl="VC for scanl_length">
 <proof prover="3"><undone/></proof>
 </goal>
 <goal name="scanl_cons">
 <proof prover="1"><undone/></proof>
 </goal>
</theory>
<theory name="ListScanMonoid">
 <goal name="map_scanl&#39;vc" expl="VC for map_scanl">
 <transf name="split_vc" >
  <goal name="map_scanl&#39;vc.0" expl="assertion">
  <proof prover="1"><undone/></proof>
  </goal>
  <goal name="map_scanl&#39;vc.1" expl="assertion">
  <proof prover="3"><undone/></proof>
  </goal>
  <goal name="map_scanl&#39;vc.2" expl="assertion">
  <proof prover="1"><undone/></proof>
  </goal>
  <goal name="map_scanl&#39;vc.3" expl="precondition">
  <proof prover="1"><undone/></proof>
  </goal>
  <goal name="map_scanl&#39;vc.4" expl="postcondition">
  <proof prover="1" timelimit="8" memlimit="4000"><undone/></proof>
  </goal>
 </transf>
 </goal>
 <goal name="scanl_inv&#39;vc" expl="VC for scanl_inv">
 <proof prover="1"><undone/></proof>
 <proof prover="3"><undone/></proof>
 <transf name="split_vc" >
  <goal name="scanl_inv&#39;vc.0" expl="assertion">
  <proof prover="1"><undone/></proof>
  <proof prover="3"><undone/></proof>
  <transf name="split_vc" >
   <goal name="scanl_inv&#39;vc.0.0" expl="assertion">
   <proof prover="1"><undone/></proof>
   </goal>
   <goal name="scanl_inv&#39;vc.0.1" expl="VC for scanl_inv">
   <proof prover="1"><undone/></proof>
   </goal>
   <goal name="scanl_inv&#39;vc.0.2" expl="VC for scanl_inv">
   <proof prover="1" timelimit="8" memlimit="4000"><undone/></proof>
   </goal>
   <goal name="scanl_inv&#39;vc.0.3" expl="VC for scanl_inv">
   <proof prover="1" timelimit="8" memlimit="4000"><undone/></proof>
   </goal>
  </transf>
  </goal>
  <goal name="scanl_inv&#39;vc.1" expl="postcondition">
  <proof prover="1"><undone/></proof>
  <proof prover="3"><undone/></proof>
  <transf name="split_vc" >
   <goal name="scanl_inv&#39;vc.1.0" expl="postcondition">
   <proof prover="3"><undone/></proof>
   </goal>
   <goal name="scanl_inv&#39;vc.1.1" expl="postcondition">
   <proof prover="1" timelimit="8" memlimit="4000"><undone/></proof>
   </goal>
  </transf>
  </goal>
 </transf>
 </goal>
 <goal name="scanl_map_gen&#39;vc" expl="VC for scanl_map_gen">
 <transf name="split_vc" >
  <goal name="scanl_map_gen&#39;vc.0" expl="assertion" proved="true">
  <proof prover="1" timelimit="5" memlimit="2000"><result status="valid" time="1.047027" steps="81772"/></proof>
  </goal>
  <goal name="scanl_map_gen&#39;vc.1" expl="assertion" proved="true">
  <transf name="split_vc" proved="true" >
   <goal name="scanl_map_gen&#39;vc.1.0" expl="assertion" proved="true">
   <proof prover="1" timelimit="30" memlimit="4000"><result status="valid" time="7.733203" steps="480321"/></proof>
   </goal>
   <goal name="scanl_map_gen&#39;vc.1.1" expl="assertion" proved="true">
   <proof prover="1" timelimit="8" memlimit="4000"><result status="valid" time="10.206434" steps="512135"/></proof>
   </goal>
   <goal name="scanl_map_gen&#39;vc.1.2" expl="assertion" proved="true">
   <proof prover="3"><result status="valid" time="0.054991" steps="165"/></proof>
   </goal>
   <goal name="scanl_map_gen&#39;vc.1.3" expl="assertion" proved="true">
   <proof prover="3"><result status="valid" time="0.055732" steps="213"/></proof>
   </goal>
   <goal name="scanl_map_gen&#39;vc.1.4" expl="VC for scanl_map_gen" proved="true">
   <proof prover="1" timelimit="30" memlimit="4000"><result status="valid" time="15.165363" steps="628156"/></proof>
   </goal>
  </transf>
  </goal>
  <goal name="scanl_map_gen&#39;vc.2" expl="precondition" proved="true">
  <proof prover="3"><result status="valid" time="0.031418" steps="22"/></proof>
  </goal>
  <goal name="scanl_map_gen&#39;vc.3" expl="precondition" proved="true">
  <proof prover="3"><result status="valid" time="0.051040" steps="201"/></proof>
  </goal>
  <goal name="scanl_map_gen&#39;vc.4" expl="precondition" proved="true">
  <proof prover="3"><result status="valid" time="0.031700" steps="24"/></proof>
  </goal>
  <goal name="scanl_map_gen&#39;vc.5" expl="precondition" proved="true">
  <proof prover="3"><result status="valid" time="0.029149" steps="24"/></proof>
  </goal>
  <goal name="scanl_map_gen&#39;vc.6" expl="precondition" proved="true">
  <proof prover="3"><result status="valid" time="0.032400" steps="24"/></proof>
  </goal>
  <goal name="scanl_map_gen&#39;vc.7" expl="precondition" proved="true">
  <proof prover="3"><result status="valid" time="0.053923" steps="210"/></proof>
  </goal>
  <goal name="scanl_map_gen&#39;vc.8" expl="precondition">
  <proof prover="3"><undone/></proof>
  </goal>
  <goal name="scanl_map_gen&#39;vc.9" expl="precondition">
  <proof prover="3"><undone/></proof>
  </goal>
  <goal name="scanl_map_gen&#39;vc.10" expl="precondition">
  <proof prover="3"><undone/></proof>
  </goal>
  <goal name="scanl_map_gen&#39;vc.11" expl="precondition">
  <proof prover="3"><undone/></proof>
  </goal>
  <goal name="scanl_map_gen&#39;vc.12" expl="precondition">
  <proof prover="3"><undone/></proof>
  </goal>
  <goal name="scanl_map_gen&#39;vc.13" expl="precondition">
  <proof prover="3"><undone/></proof>
  </goal>
  <goal name="scanl_map_gen&#39;vc.14" expl="assertion">
  <proof prover="3"><undone/></proof>
  </goal>
  <goal name="scanl_map_gen&#39;vc.15" expl="precondition">
  <proof prover="1"><undone/></proof>
  </goal>
  <goal name="scanl_map_gen&#39;vc.16" expl="precondition">
  <proof prover="3"><undone/></proof>
  </goal>
  <goal name="scanl_map_gen&#39;vc.17" expl="assertion">
  <transf name="split_vc" >
   <goal name="scanl_map_gen&#39;vc.17.0" expl="assertion">
   <proof prover="3"><undone/></proof>
   </goal>
   <goal name="scanl_map_gen&#39;vc.17.1" expl="assertion">
   <proof prover="1"><undone/></proof>
   </goal>
   <goal name="scanl_map_gen&#39;vc.17.2" expl="assertion">
   <proof prover="1" timelimit="8" memlimit="4000"><undone/></proof>
   </goal>
   <goal name="scanl_map_gen&#39;vc.17.3" expl="assertion" proved="true">
   <transf name="apply" proved="true" arg1="map_map">
   </transf>
   </goal>
   <goal name="scanl_map_gen&#39;vc.17.4" expl="VC for scanl_map_gen">
   <proof prover="1" timelimit="8" memlimit="4000"><undone/></proof>
   </goal>
   <goal name="scanl_map_gen&#39;vc.17.5" expl="VC for scanl_map_gen">
   <transf name="apply" arg1="map_ext_inv" arg2="with" arg3="inv">
    <goal name="scanl_map_gen&#39;vc.17.5.0" expl="apply premises">
    <proof prover="1"><undone/></proof>
    </goal>
    <goal name="scanl_map_gen&#39;vc.17.5.1" expl="apply premises">
    <proof prover="3"><undone/></proof>
    </goal>
   </transf>
   </goal>
   <goal name="scanl_map_gen&#39;vc.17.6" expl="VC for scanl_map_gen">
   <transf name="rewrite" arg1="H1">
    <goal name="scanl_map_gen&#39;vc.17.6.0" expl="VC for scanl_map_gen">
    <transf name="rewrite" arg1="H">
     <goal name="scanl_map_gen&#39;vc.17.6.0.0" expl="VC for scanl_map_gen">
     <proof prover="3"><undone/></proof>
     </goal>
    </transf>
    </goal>
   </transf>
   </goal>
   <goal name="scanl_map_gen&#39;vc.17.7" expl="VC for scanl_map_gen">
   <transf name="rewrite" arg1="H1">
    <goal name="scanl_map_gen&#39;vc.17.7.0" expl="VC for scanl_map_gen">
    <transf name="rewrite" arg1="H">
     <goal name="scanl_map_gen&#39;vc.17.7.0.0" expl="VC for scanl_map_gen">
     <proof prover="3"><undone/></proof>
     </goal>
    </transf>
    </goal>
   </transf>
   </goal>
   <goal name="scanl_map_gen&#39;vc.17.8" expl="VC for scanl_map_gen">
   <transf name="rewrite" arg1="H1">
    <goal name="scanl_map_gen&#39;vc.17.8.0" expl="VC for scanl_map_gen">
    <transf name="rewrite" arg1="H">
     <goal name="scanl_map_gen&#39;vc.17.8.0.0" expl="VC for scanl_map_gen">
     <proof prover="3" timelimit="5"><undone/></proof>
     </goal>
    </transf>
    </goal>
   </transf>
   </goal>
  </transf>
  </goal>
  <goal name="scanl_map_gen&#39;vc.18" expl="postcondition">
  <proof prover="1" timelimit="1"><undone/></proof>
  <proof prover="3" timelimit="1"><undone/></proof>
  <transf name="split_vc" >
   <goal name="scanl_map_gen&#39;vc.18.0" expl="postcondition">
   <proof prover="1"><undone/></proof>
   </goal>
   <goal name="scanl_map_gen&#39;vc.18.1" expl="postcondition">
   <proof prover="1" timelimit="30" memlimit="4000"><undone/></proof>
   </goal>
  </transf>
  </goal>
 </transf>
 </goal>
</theory>
</file>
<file format="whyml" proved="true">
<path name=".."/><path name="skeletons.mlw"/>
<theory name="Skeletons" proved="true">
 <goal name="map_par&#39;vc" expl="VC for map_par" proved="true">
 <proof prover="1"><result status="timeout" time="2.000000" steps="142289"/></proof>
 <proof prover="3"><result status="timeout" time="2.000000" steps="14633"/></proof>
 <transf name="split_vc" proved="true" >
  <goal name="map_par&#39;vc.0" expl="postcondition" proved="true">
  <proof prover="3"><result status="valid" time="0.077658" steps="128"/></proof>
  </goal>
  <goal name="map_par&#39;vc.1" expl="postcondition" proved="true">
  <proof prover="3"><result status="valid" time="1.349359" steps="8787"/></proof>
  </goal>
 </transf>
 </goal>
 <goal name="reduce_par&#39;vc" expl="VC for reduce_par" proved="true">
 <proof prover="1"><result status="timeout" time="2.000000" steps="129775"/></proof>
 <proof prover="3"><result status="timeout" time="2.000000" steps="13576"/></proof>
 <transf name="split_vc" proved="true" >
  <goal name="reduce_par&#39;vc.0" expl="precondition" proved="true">
  <proof prover="3"><result status="valid" time="0.049822" steps="22"/></proof>
  </goal>
  <goal name="reduce_par&#39;vc.1" expl="precondition" proved="true">
  <proof prover="3"><result status="valid" time="0.048125" steps="22"/></proof>
  </goal>
  <goal name="reduce_par&#39;vc.2" expl="precondition" proved="true">
  <proof prover="3"><result status="valid" time="0.056554" steps="22"/></proof>
  </goal>
  <goal name="reduce_par&#39;vc.3" expl="precondition" proved="true">
  <proof prover="3"><result status="valid" time="0.050558" steps="22"/></proof>
  </goal>
  <goal name="reduce_par&#39;vc.4" expl="precondition" proved="true">
  <proof prover="3"><result status="valid" time="0.109810" steps="314"/></proof>
  </goal>
  <goal name="reduce_par&#39;vc.5" expl="postcondition" proved="true">
  <proof prover="1" timelimit="8" memlimit="4000"><result status="valid" time="2.197701" steps="165103"/></proof>
  </goal>
 </transf>
 </goal>
</theory>
</file>
<file format="whyml" proved="true">
<path name=".."/><path name="stdlib.mlw"/>
<theory name="Base" proved="true">
 <goal name="procs&#39;vc" expl="VC for procs" proved="true">
 <proof prover="3"><result status="valid" time="0.076650" steps="150"/></proof>
 </goal>
 <goal name="this&#39;vc" expl="VC for this" proved="true">
 <proof prover="3"><result status="valid" time="0.068561" steps="70"/></proof>
 </goal>
 <goal name="replicate&#39;vc" expl="VC for replicate" proved="true">
 <proof prover="3"><result status="valid" time="0.064838" steps="67"/></proof>
 </goal>
 <goal name="parfun&#39;vc" expl="VC for parfun" proved="true">
 <proof prover="3"><result status="valid" time="0.064116" steps="75"/></proof>
 </goal>
 <goal name="parfun2&#39;vc" expl="VC for parfun2" proved="true">
 <proof prover="3"><result status="valid" time="0.057447" steps="28"/></proof>
 </goal>
 <goal name="parfun3&#39;vc" expl="VC for parfun3" proved="true">
 <proof prover="3"><result status="valid" time="0.059799" steps="28"/></proof>
 </goal>
 <goal name="list_of_par&#39;vc" expl="VC for list_of_par" proved="true">
 <proof prover="3"><result status="valid" time="0.125768" steps="345"/></proof>
 </goal>
 <goal name="apply2&#39;vc" expl="VC for apply2" proved="true">
 <proof prover="3"><result status="valid" time="0.060292" steps="28"/></proof>
 </goal>
 <goal name="applyif&#39;vc" expl="VC for applyif" proved="true">
 <proof prover="3"><result status="valid" time="0.171199" steps="650"/></proof>
 </goal>
 <goal name="applyat&#39;vc" expl="VC for applyat" proved="true">
 <proof prover="3"><result status="valid" time="0.077592" steps="133"/></proof>
 </goal>
 <goal name="mask&#39;vc" expl="VC for mask" proved="true">
 <proof prover="3"><result status="valid" time="0.171794" steps="707"/></proof>
 </goal>
</theory>
<theory name="Comm" proved="true">
 <goal name="shift_pid_lt" proved="true">
 <proof prover="3"><result status="valid" time="0.058038" steps="28"/></proof>
 </goal>
 <goal name="shift_pid_ge" proved="true">
 <proof prover="3"><result status="valid" time="0.067848" steps="28"/></proof>
 </goal>
 <goal name="shift_id" proved="true">
 <proof prover="3"><result status="valid" time="0.073114" steps="75"/></proof>
 </goal>
 <goal name="shift&#39;vc" expl="VC for shift" proved="true">
 <proof prover="1"><result status="timeout" time="2.000000" steps="232566"/></proof>
 <proof prover="3"><result status="timeout" time="2.000000" steps="15417"/></proof>
 <transf name="split_vc" proved="true" >
  <goal name="shift&#39;vc.0" expl="postcondition" proved="true">
  <proof prover="1"><result status="timeout" time="2.000000" steps="220392"/></proof>
  <proof prover="3"><result status="timeout" time="2.000000" steps="13806"/></proof>
  <transf name="split_vc" proved="true" >
   <goal name="shift&#39;vc.0.0" expl="postcondition" proved="true">
   <proof prover="3"><result status="valid" time="0.049713" steps="20"/></proof>
   </goal>
   <goal name="shift&#39;vc.0.1" expl="postcondition" proved="true">
   <proof prover="1" timelimit="8" memlimit="4000"><result status="valid" time="4.190429" steps="375830"/></proof>
   </goal>
  </transf>
  </goal>
  <goal name="shift&#39;vc.1" expl="postcondition" proved="true">
  <proof prover="3"><result status="valid" time="0.053193" steps="20"/></proof>
  </goal>
 </transf>
 </goal>
 <goal name="shift_right&#39;vc" expl="VC for shift_right" proved="true">
 <proof prover="3"><result status="valid" time="0.128948" steps="359"/></proof>
 </goal>
 <goal name="shift_left&#39;vc" expl="VC for shift_left" proved="true">
 <proof prover="3"><result status="valid" time="0.126811" steps="398"/></proof>
 </goal>
 <goal name="totex&#39;vc" expl="VC for totex" proved="true">
 <proof prover="3"><result status="valid" time="0.112444" steps="289"/></proof>
 </goal>
 <goal name="total_exchange&#39;vc" expl="VC for total_exchange" proved="true">
 <proof prover="3"><result status="valid" time="1.251455" steps="8030"/></proof>
 </goal>
 <goal name="bcast_proj&#39;vc" expl="VC for bcast_proj" proved="true">
 <proof prover="3"><result status="valid" time="0.067664" steps="30"/></proof>
 </goal>
 <goal name="bcast_direct&#39;vc" expl="VC for bcast_direct" proved="true">
 <proof prover="1"><result status="valid" time="0.733069" steps="70512"/></proof>
 </goal>
 <goal name="gather&#39;vc" expl="VC for gather" proved="true">
 <proof prover="3"><result status="valid" time="1.213941" steps="9181"/></proof>
 </goal>
 <goal name="gather_list&#39;vc" expl="VC for gather_list" proved="true">
 <proof prover="1"><result status="timeout" time="2.000000" steps="170474"/></proof>
 <proof prover="3"><result status="timeout" time="2.000000" steps="16084"/></proof>
 <transf name="split_vc" proved="true" >
  <goal name="gather_list&#39;vc.0" expl="precondition" proved="true">
  <proof prover="3"><result status="valid" time="0.058815" steps="16"/></proof>
  </goal>
  <goal name="gather_list&#39;vc.1" expl="postcondition" proved="true">
  <proof prover="1" timelimit="8" memlimit="4000"><result status="valid" time="2.335268" steps="177779"/></proof>
  </goal>
  <goal name="gather_list&#39;vc.2" expl="postcondition" proved="true">
  <proof prover="1" timelimit="8" memlimit="4000"><result status="valid" time="1.251672" steps="118805"/></proof>
  </goal>
 </transf>
 </goal>
 <goal name="scatter&#39;vc" expl="VC for scatter" proved="true">
 <proof prover="1"><result status="timeout" time="2.000000" steps="159422"/></proof>
 <proof prover="3"><result status="timeout" time="2.000000" steps="14093"/></proof>
 <transf name="split_vc" proved="true" >
  <goal name="scatter&#39;vc.0" expl="postcondition" proved="true">
  <proof prover="1" timelimit="32" memlimit="4000"><result status="valid" time="5.353743" steps="280429"/></proof>
  </goal>
  <goal name="scatter&#39;vc.1" expl="postcondition" proved="true">
  <proof prover="3"><result status="valid" time="0.050495" steps="14"/></proof>
  </goal>
 </transf>
 </goal>
</theory>
</file>
</why3session>
